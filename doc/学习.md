# 1.dddmr_lego_loam
## 1.1.optimized_ICP_GN
基于高斯-牛顿优化方法的ICP算法，用于匹配两个点云。
## 1.2.optimized_ICP_GN_playground
一个测试程序，测试和演示1.1的算法性能。核心工作是：生成一个已知变换的点云，然后用1.1的算法估计这个变换，评估其精度。
## 1.3.pointcloud2occupancy
将点云数据转换为占据栅格地图。
## 1.4.pose_graph_editor
对已经构建的位姿图进行手动编辑、优化和保存。
## 1.5.pose_graph_merge_editor
将两个独立的位姿图通过手动指定关联点进行ICP配准，合并成一个全局一致的位姿图。
## 1.6.pose_graph_editor_node
位姿图管理节点，动态加载、管理多个独立的位姿图（子图），并为这些位姿图的合并操作提供支持。
## 1.7.imageProjection
对原始激光雷达点云进行预处理，包括投影、地面移除、点云分割和特征提取。  
`_sub_laser_cloud`订阅原始的激光雷达点云话题（B2的应为`/rslidar_points`）。  
`ImageProjection`函数中声明并获取了大量雷达相关参数，需要传入这些参数。
## 1.8.featureAssociation
处理激光雷达数据，提取并匹配特征点，从而计算机器人在连续帧之间的精确位姿变换（里程计）。  
参数`isDegenerate`用来判定是否是退化场景，处理简单的退化。
## 1.9.mapOptimization
接收前端的特征点云，通过scan-to-map匹配和因子图优化，输出高精度的机器人位姿和全局一致的地图。
## 1.10.interactive_pose_graph_editor
一个交互式的位姿图编辑器，实现手动选择关节帧，进行ICP配准、手动调整位姿等功能。
# 2.dddmr_mcl_3dl
## 2.1.lidar_measurement_model_likelihood
是一个​​集成了地面约束的似然域激光测量模型​​。它通过​​计算观测点云与地图的匹配距离​​，并​​结合粒子姿态相对于地面的合理性权重​​，来综合评价一个粒子的观测似然。其设计充分考虑了​​结构化环境中的地面先验知识​​，并通过​​自适应调整计算策略​​来平衡全局定位和局部跟踪的需求。
## 2.2.parameters
集中化的参数管理类。
## 2.3.pcl_publisher
读取、变换、简化并发布点云地图​​。
## 2.4.sub_maps
根据机器人的实时位姿，动态加载、切换并发布局部子地图（特征点和地面点），为定位算法提供适应当前环境的局部地图信息。
## 2.5.mcl_3dl
这段代码实现了一个基于 ROS 2 的3D蒙特卡洛定位 (MCL) 节点 (MCL3dlNode)，它使用粒子滤波算法融合激光雷达特征点云和里程计数据，来估计机器人在三维空间中的精确位姿（位置和朝向）。这是一个用于机器人3D定位的核心模块。


🔧 工作原理与流程

该节点的核心是粒子滤波算法，其工作流程围绕预测-更新循环展开：

1. **初始化 `configure`**  
- 从参数服务器读取所有配置。  
- 初始化粒子滤波器 `pf_`，给定初始位姿和方差，粒子均匀分布在初始位姿周围。  
- 初始化运动模型（差分驱动模型）和测量模型（似然域模型）。  
- 创建订阅器（里程计、初始位姿、激光特征点云）和发布器（位姿、粒子、TF等）。  
- 初始化TF监听器和广播器。  

2. **预测阶段（处理里程计 `cbOdom`）**
- 当收到新的里程计消息时，计算当前里程计与上一时刻的相对运动增量（平移和旋转）。
- 如果运动增量超过阈值（update_min_d_, update_min_a_），则触发核心流程。
- 调用运动模型的 predict 函数，将相对运动（叠加噪声）应用到每一个粒子上，预测它们在当前时刻的可能状态。这步体现了里程计的推测航位功能。

3. **更新阶段（处理激光特征 `cbLeGoFeatureCloud` + `measure`）**
- 特征预处理: 当同步收到四种特征点云时：
    - 将其从传感器坐标系变换到机器人基坐标系 (`base_link`)。
    - 对点云进行降采样以减少计算量。
    - **法线估计** 或 **欧氏聚类**，并基于此计算每个点的权重 (intensity)。法线(dominant)或聚类较小的点通常赋予更高权重，因为它们可能代表更独特、更稳定的特征。
    - 存储处理后的特征点云 `pcl_segmentations_`。

- 测量更新: 在 `cbOdom` 中预测完成后，立即调用 `measure` 函数：

    - 遍历每个粒子，使用测量模型 `lidar_measurements_->measure` 计算该粒子位姿下的观测似然。即，将当前观测的特征点云“放置”在该粒子代表的位置上，然后与子地图中的点进行匹配，计算匹配得分（权重）。
    - 根据里程计积分误差为粒子添加一个偏置权重 (bias_func)，惩罚那些与上一时刻估计位姿偏离过大的粒子，增强稳定性。
    - 综合观测似然和偏置权重，更新每个粒子的最终权重。

4. **重采样与状态估计**
- 根据粒子权重进行重采样：淘汰低权重粒子，复制高权重粒子，从而使粒子聚集在高似然区域。
- 重采样后注入少量噪声 `pf_->noise`，增加粒子多样性，避免粒子退化。
- 计算所有粒子的加权平均作为最优位姿估计 `e = pf_->expectationBiased()` 和协方差矩阵。

5. **发布结果**
- 发布估计的位姿消息 `pub_pose_->publish(pose)`。
- 计算并发布从 `map` 坐标系到 `odom` 坐标系的TF变换 `tfb_->sendTransform`。这是为了修正里程计的漂移，使得基于 odom 的其它数据（如传感器数据）能够正确地映射到全局地图坐标系 map 中。
- 发布粒子集用于可视化 `publishParticles()`。

6. **初始化和重置**
- cbPosition: 允许外部设置初始位姿，用于全局定位或重定位。
- 当匹配度极低 (`match_ratio_max < match_ratio_thresh_`) 时，认为定位失败，进行扩张重置 `pf_->noise`，在更大范围内撒粒子，重新进行全局定位。

💡 关键技术与算法

- 粒子滤波 (Particle Filter): 核心算法，用于处理非高斯的位姿估计问题。
- 似然域模型 (Likelihood Field Model): 用于计算激光点云与地图的匹配得分，比波束模型更鲁棒。
- KD-Tree 近邻搜索: 在测量模型中用于快速查找最近邻点，是高效计算匹配得分的关键。
- 运动模型 (Differential Drive): 基于差分驱动模型，根据里程计数据预测粒子运动。
- 点云处理: 大量使用PCL库进行特征提取、降采样、法线估计和聚类。

⚠️ 注意事项

- 参数调优: 算法性能高度依赖于大量参数（粒子数、各种噪声参数、阈值等），需要仔细调整。
- 计算效率: 粒子数量、点云密度和地图大小直接影响计算开销，需要在性能和精度之间权衡。
- 坐标系管理: 涉及多个坐标系（map, odom, base_link, 传感器帧），需要确保正确的变换关系。
- 初始位姿: 在全局定位模式下，需要提供初始位姿或较大的初始不确定性，否则可能收敛到错误位置。

📊 总结

总而言之，MCL3dlNode 是一个功能完整且复杂的3D激光雷达定位节点。它通过粒子滤波算法，巧妙地融合了里程计的运动预测和激光雷达特征点的观测更新，实现了在已知点云地图中的6自由度位姿估计。其设计包含了处理大规模环境、防止粒子退化、支持重定位等实用功能，是自动驾驶和移动机器人领域中一个可靠的定位解决方案。